# **üìù Bash Error Handling: Short Notes**

## **‚úÖ BASIC ERROR HANDLING**

### **1. Exit Status**
Every command returns **exit code** (0=success, non-zero=failure)
```bash
ls /valid/path
echo $?  # Output: 0

ls /invalid/path
echo $?  # Output: 2
```

### **2. Check Exit Status**
```bash
#!/bin/bash
cp source.txt dest.txt
if [ $? -eq 0 ]; then
    echo "Copy successful"
else
    echo "Copy failed with code: $?"
fi
```

---

## **üéØ SET COMMAND OPTIONS**

### **Common Options:**
- `set -e`: Exit on error
- `set -u`: Exit on undefined variable
- `set -o pipefail`: Fail if any command in pipe fails
- `set -x`: Debug mode (print commands)

### **Example 1: Strict Mode**
```bash
#!/bin/bash
set -euo pipefail  # Enable all safety features

echo "Starting script..."
rm -f /tmp/myfile  # If this fails, script exits
echo "File removed"  # Won't reach here if rm fails
```

### **Example 2: Debug Mode**
```bash
#!/bin/bash
set -x  # Enable debug

name="Jetha"
age=45
echo "Name: $name, Age: $age"

set +x  # Disable debug
echo "Debug turned off"
```
**Output:**
```
+ name=Jetha
+ age=45
+ echo 'Name: Jetha, Age: 45'
Name: Jetha, Age: 45
+ set +x
Debug turned off
```

---

## **üîß TRAP COMMAND (SIGNAL HANDLING)**

### **Syntax:**
```bash
trap 'cleanup_function' SIGNAL
```

### **Common Signals:**
- `EXIT`: Script exits
- `ERR`: Command fails
- `INT`: Ctrl+C
- `TERM`: Termination request

### **Example 3: Cleanup on Exit**
```bash
#!/bin/bash
temp_file="/tmp/temp_$$.txt"

cleanup() {
    echo "Cleaning up..."
    rm -f "$temp_file"
    echo "Cleanup complete"
}

trap cleanup EXIT  # Run cleanup on exit
trap 'echo "Ctrl+C pressed"; exit 1' INT  # Handle Ctrl+C

echo "Creating temp file..."
echo "Data" > "$temp_file"
echo "Temp file created"
# Script continues...
```
**Output (on normal exit):**
```
Creating temp file...
Temp file created
Cleaning up...
Cleanup complete
```

### **Example 4: Error Trap**
```bash
#!/bin/bash
error_handler() {
    echo "Error at line: $LINENO"
    echo "Command: $BASH_COMMAND"
    echo "Exit code: $?"
}

trap error_handler ERR

rm /nonexistent/file  # This will trigger error
echo "This won't execute"
```
**Output:**
```
rm: cannot remove '/nonexistent/file': No such file or directory
Error at line: 9
Command: rm /nonexistent/file
Exit code: 1
```

---

## **üí° PRACTICAL ERROR HANDLING**

### **Example 5: File Operations with Validation**
```bash
#!/bin/bash
set -e

backup_file() {
    local src=$1
    local dest=$2
    
    # Validate inputs
    if [ -z "$src" ] || [ -z "$dest" ]; then
        echo "ERROR: Source and destination required"
        return 1
    fi
    
    if [ ! -f "$src" ]; then
        echo "ERROR: Source file '$src' not found"
        return 1
    fi
    
    if [ ! -d "$(dirname "$dest")" ]; then
        echo "ERROR: Destination directory doesn't exist"
        return 1
    fi
    
    # Perform backup
    cp "$src" "$dest"
    echo "Backup successful: $src -> $dest"
    return 0
}

# Usage
backup_file "/etc/hosts" "/backup/hosts.bak" || echo "Backup failed"
```

### **Example 6: Network Check with Retry**
```bash
#!/bin/bash
MAX_RETRIES=3
RETRY_DELAY=2

ping_host() {
    local host=$1
    local attempt=1
    
    while [ $attempt -le $MAX_RETRIES ]; do
        echo "Attempt $attempt to ping $host..."
        
        if ping -c 1 "$host" &>/dev/null; then
            echo "SUCCESS: $host is reachable"
            return 0
        else
            echo "FAILED attempt $attempt"
            sleep $RETRY_DELAY
            ((attempt++))
        fi
    done
    
    echo "ERROR: Failed to reach $host after $MAX_RETRIES attempts"
    return 1
}

# Usage
ping_host "google.com" || echo "Network check failed"
```

---

## **‚ö° ADVANCED TECHNIQUES**

### **1. Custom Error Function**
```bash
#!/bin/bash
log_error() {
    local message=$1
    local code=${2:-1}  # Default exit code 1
    
    echo "ERROR: $message" >&2  # Send to stderr
    echo "Line: $LINENO, Function: ${FUNCNAME[1]}" >&2
    exit $code
}

# Usage
[ -f "/etc/passwd" ] || log_error "File not found" 2
echo "This won't execute if file missing"
```

### **2. Try-Catch Pattern**
```bash
#!/bin/bash
try() {
    "$@"  # Execute command
    local status=$?
    
    if [ $status -ne 0 ]; then
        echo "ERROR: Command failed: $@"
        return $status
    fi
    return 0
}

catch() {
    local status=$?
    echo "Exit code: $status"
    # Recovery logic here
}

# Usage
try rm /nonexistent/file
catch  # Handle the error
```

### **3. Error Logging to File**
```bash
#!/bin/bash
LOG_FILE="/var/log/myapp_error.log"

log_error() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local message="$timestamp [ERROR] $1 (Line: $LINENO)"
    
    echo "$message" >> "$LOG_FILE"
    echo "$message" >&2  # Also print to stderr
}

# Usage
find /etc -name "*.conf" 2>/dev/null || log_error "Find command failed"
```

---

## **üõ°Ô∏è DEFENSIVE SCRIPTING**

### **Example 7: Safe Variable Usage**
```bash
#!/bin/bash
set -u  # Exit on undefined variable

# Safe variable assignment with defaults
: ${BACKUP_DIR:="/backup"}  # Use /backup if not set
: ${MAX_FILES:=100}
: ${USERNAME:? "USERNAME must be set"}  # Exit if not set

echo "Backup dir: $BACKUP_DIR"
echo "Max files: $MAX_FILES"
echo "User: $USERNAME"
```

### **Example 8: Input Validation**
```bash
#!/bin/bash
validate_number() {
    local input=$1
    
    # Check if it's a number
    if ! [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "ERROR: '$input' is not a valid number" >&2
        return 1
    fi
    
    # Check range
    if [ "$input" -lt 1 ] || [ "$input" -gt 100 ]; then
        echo "ERROR: Number must be between 1 and 100" >&2
        return 1
    fi
    
    return 0
}

# Usage
read -p "Enter age (1-100): " age
validate_number "$age" || exit 1
echo "Valid age: $age"
```

---

## **üéØ ERROR CODES TABLE**

| Code | Meaning | Common Commands |
|------|---------|-----------------|
| 0 | Success | All successful commands |
| 1 | General error | `false`, `test` failures |
| 2 | Misuse of shell builtins | `bash`, `cd` errors |
| 126 | Command invoked cannot execute | Permission denied |
| 127 | Command not found | Typo in command |
| 128+N | Fatal error signal N | `kill -9` gives 137 (128+9) |
| 130 | Script terminated by Ctrl+C | User interrupt |

### **Example 9: Custom Exit Codes**
```bash
#!/bin/bash
SUCCESS=0
FILE_NOT_FOUND=10
PERMISSION_DENIED=20
INVALID_INPUT=30

process_file() {
    local file=$1
    
    if [ ! -f "$file" ]; then
        return $FILE_NOT_FOUND
    fi
    
    if [ ! -r "$file" ]; then
        return $PERMISSION_DENIED
    fi
    
    # Process file
    echo "Processing $file"
    return $SUCCESS
}

# Usage
process_file "data.txt"
case $? in
    $SUCCESS) echo "Success" ;;
    $FILE_NOT_FOUND) echo "File not found" ;;
    $PERMISSION_DENIED) echo "Permission denied" ;;
    *) echo "Unknown error" ;;
esac
```

---

## **üö® COMMON PITFALLS & SOLUTIONS**

### **Pitfall 1: Missing set -e**
```bash
#!/bin/bash
# WRONG: Error continues silently
rm /nonexistent/file
echo "Continuing..."  # Still executes!

# RIGHT:
set -e
rm /nonexistent/file  # Script exits here
echo "Continuing..."  # Never reached
```

### **Pitfall 2: Unhandled Pipe Errors**
```bash
#!/bin/bash
# WRONG: Only checks last command's exit
cat file.txt | grep "pattern" | wc -l
echo $?  # Only shows wc -l exit code

# RIGHT:
set -o pipefail
cat file.txt | grep "pattern" | wc -l
echo $?  # Shows if ANY command in pipe failed
```

### **Pitfall 3: Unquoted Variables**
```bash
#!/bin/bash
# WRONG: Breaks with spaces
files="/path with spaces/file.txt"
rm $files  # Tries: rm /path with spaces/file.txt

# RIGHT:
rm "$files"  # Quotes preserve spaces
```

---

## **üìä REAL-WORLD EXAMPLES**

### **Case 1: Database Backup Script**
```bash
#!/bin/bash
set -euo pipefail
trap 'echo "Backup interrupted"; exit 1' INT TERM

BACKUP_DIR="/backup"
DB_NAME="mydb"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Validate
[ -d "$BACKUP_DIR" ] || { echo "Backup directory missing"; exit 1; }
which mysqldump >/dev/null || { echo "mysqldump not found"; exit 1; }

echo "Starting backup of $DB_NAME..."
mysqldump -u root "$DB_NAME" | gzip > "$BACKUP_DIR/${DB_NAME}_${TIMESTAMP}.sql.gz"

if [ $? -eq 0 ] && [ -s "$BACKUP_DIR/${DB_NAME}_${TIMESTAMP}.sql.gz" ]; then
    echo "Backup successful: ${DB_NAME}_${TIMESTAMP}.sql.gz"
    exit 0
else
    echo "Backup failed!" >&2
    exit 1
fi
```

### **Case 2: Deployment Script**
```bash
#!/bin/bash
set -e

deploy() {
    local env=$1
    local version=$2
    
    echo "Deploying version $version to $env..."
    
    # Validate environment
    case "$env" in
        staging|production)
            ;;
        *)
            echo "ERROR: Invalid environment '$env'"
            return 1
            ;;
    esac
    
    # Check version format
    if ! [[ "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "ERROR: Invalid version format '$version'"
        return 1
    fi
    
    # Deployment steps
    echo "Pulling $version..."
    # git pull, restart services, etc.
    
    echo "Deployment completed successfully"
    return 0
}

# Usage with error handling
if ! deploy "$1" "$2"; then
    echo "Deployment failed. Check logs." >&2
    exit 1
fi
```

### **Case 3: API Health Check**
```bash
#!/bin/bash
set -eo pipefail

check_api() {
    local url=$1
    local timeout=${2:-10}
    
    echo "Checking $url..."
    
    response=$(curl -s -f -m "$timeout" "$url" || echo "CURL_FAILED")
    
    if [ "$response" = "CURL_FAILED" ]; then
        echo "ERROR: API unreachable"
        return 1
    fi
    
    # Check response content
    if ! echo "$response" | jq -e '.status == "ok"' >/dev/null 2>&1; then
        echo "ERROR: Invalid API response"
        return 1
    fi
    
    echo "API is healthy"
    return 0
}

# Monitor multiple endpoints
endpoints=(
    "https://api.example.com/health"
    "https://db.example.com/ping"
    "https://cache.example.com/status"
)

for endpoint in "${endpoints[@]}"; do
    if ! check_api "$endpoint"; then
        echo "CRITICAL: $endpoint is down" >&2
        exit 1
    fi
done

echo "All systems operational"
```

---

## **‚úÖ BEST PRACTICES**

1. **Always use `set -euo pipefail`** at script start
2. **Validate all inputs** before processing
3. **Use meaningful exit codes** (not just 0/1)
4. **Log errors to stderr** (`>&2`)
5. **Clean up resources** with `trap EXIT`
6. **Test error conditions** deliberately
7. **Document error behavior** in comments

---

## **üöÄ MINI PROJECT: Robust File Processor**
```bash
#!/bin/bash
# robust_processor.sh
set -euo pipefail

# Configuration
LOG_FILE="$(dirname "$0")/processor.log"
MAX_FILE_SIZE=10485760  # 10MB

# Logging
log() {
    local level=$1
    local message=$2
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $message" | tee -a "$LOG_FILE"
}

# Error handling
handle_error() {
    log "ERROR" "Script failed at line $1: $2"
    exit 1
}

trap 'handle_error $LINENO "$BASH_COMMAND"' ERR

# Validate file
validate_file() {
    local file=$1
    
    if [ ! -f "$file" ]; then
        log "ERROR" "File not found: $file"
        return 1
    fi
    
    if [ ! -r "$file" ]; then
        log "ERROR" "Cannot read file: $file"
        return 1
    fi
    
    local size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file")
    if [ "$size" -gt "$MAX_FILE_SIZE" ]; then
        log "ERROR" "File too large: $(($size/1024))KB > $(($MAX_FILE_SIZE/1024))KB"
        return 1
    fi
    
    return 0
}

# Main processing
main() {
    local input_file=${1:?"Usage: $0 <input_file>"}
    
    log "INFO" "Starting processing of: $input_file"
    
    # Validate
    validate_file "$input_file" || exit 1
    
    # Create backup
    backup_file="${input_file}.backup.$(date +%s)"
    cp "$input_file" "$backup_file"
    log "INFO" "Backup created: $backup_file"
    
    # Process file (example: convert to uppercase)
    output_file="${input_file}.processed"
    tr '[:lower:]' '[:upper:]' < "$input_file" > "$output_file"
    
    # Verify output
    if [ -s "$output_file" ]; then
        log "INFO" "Processing successful: $output_file"
        echo "Output: $output_file"
        return 0
    else
        log "ERROR" "Processing failed - empty output"
        # Restore from backup
        cp "$backup_file" "$input_file"
        return 1
    fi
}

# Run script
main "$@"
```

---

## **üìã QUICK REFERENCE**

| Command | Purpose | Example |
|---------|---------|---------|
| `set -e` | Exit on error | `set -e` |
| `set -u` | Exit on undefined variable | `set -u` |
| `trap` | Handle signals | `trap 'cleanup' EXIT` |
| `command ||` | Run if command fails | `cmd || echo "failed"` |
| `command &&` | Run if command succeeds | `cmd && echo "success"` |
| `if [ $? -eq 0 ]` | Check exit code | `if [ $? -eq 0 ]; then` |
| `2>/dev/null` | Suppress stderr | `cmd 2>/dev/null` |
| `>&2` | Redirect to stderr | `echo "Error" >&2` |

---

## **üîç TEST YOURSELF**

**Q1: What happens here?**
```bash
#!/bin/bash
set -e
false
echo "Hello"
```
**Answer:** Script exits at `false`, "Hello" never prints.

**Q2: Fix this error-prone code:**
```bash
#!/bin/bash
file=$1
rm $file
echo "File removed"
```
**Fixed:**
```bash
#!/bin/bash
set -e
file=${1:?"Filename required"}
[ -f "$file" ] || { echo "File not found" >&2; exit 1; }
rm "$file"
echo "File removed"
```

---
#!/bin/bash

# Deploy a Django app and handle errors

# Function to clone the Django app code
code_clone() {
    echo "Cloning the Django app..."
    if [ -d "django-notes-app" ]; then
        echo "The code directory already exists. Skipping clone."
    else
        git clone https://github.com/LondheShubham153/django-notes-app.git || {
            echo "Failed to clone the code."
            return 1
        }
    fi
}

# Function to install required dependencies
install_requirements() {
    echo "Installing dependencies..."
    sudo apt-get update && sudo apt-get install -y docker.io nginx docker-compose || {
        echo "Failed to install dependencies."
        return 1
    }
}

# Function to perform required restarts
required_restarts() {
    echo "Performing required restarts..."
    sudo chown "$USER" /var/run/docker.sock || {
        echo "Failed to change ownership of docker.sock."
        return 1
    }

    # Uncomment the following lines if needed:
    # sudo systemctl enable docker
    # sudo systemctl enable nginx
    # sudo systemctl restart docker
}

# Function to deploy the Django app
deploy() {
    echo "Building and deploying the Django app..."
    docker build -t notes-app . && docker-compose up -d || {
        echo "Failed to build and deploy the app."
        return 1
    }
}

# Main deployment script
echo "********** DEPLOYMENT STARTED *********"

# Clone the code
if ! code_clone; then
    cd django-notes-app || exit 1
fi

# Install dependencies
if ! install_requirements; then
    exit 1
fi

# Perform required restarts
if ! required_restarts; then
    exit 1
fi

# Deploy the app
if ! deploy; then
    echo "Deployment failed. Mailing the admin..."
    # Add your sendmail or notification logic here
    exit 1
fi

echo "********** DEPLOYMENT DONE *********"
**Robust error handling separates amateur scripts from production-ready ones!** üõ°Ô∏è
