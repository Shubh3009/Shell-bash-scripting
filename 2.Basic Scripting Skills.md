# Day2 - Basic Scripting Skills
# **üìù Bash Comments**

## **‚úÖ SINGLE-LINE COMMENT**

### **Syntax:**
```bash
# Your comment here
```

### **Usage:**
```bash
# This is a full line comment
echo "Hello"  # This is an inline comment
# echo "This won't run"
```

### **Key Points:**
- Starts with `#`
- Ends at line end
- Can be anywhere on line
- **Ignored by shell completely**

---

## **‚úÖ MULTI-LINE COMMENT**

### **Method 1: Multiple Single Lines (Most Common)**
```bash
# Line 1 of comment
# Line 2 of comment
# Line 3 of comment
```

### **Method 2: Heredoc Trick (Block Comment)**
```bash
: << 'COMMENT'
This is a 
multi-line
comment block
COMMENT
```

**Or shorter:**
```bash
<< 'COMMENT' 2>/dev/null
Multi-line text
COMMENT
```

### **Method 3: Function Never Called**
```bash
__comment() {
    This is a 
    multi-line comment
    inside unused function
}
```


### **Wrong:**
```bash
<< COMMENT
echo "This might still execute!"
COMMENT
# Missing command before <<
```

### **Right:**
```bash
: << 'COMMENT'
echo "This won't execute"
COMMENT
```

---



---

## **üìã Summary **

```bash
# Single line comment

: << 'END_COMMENT'
Multi-line
comment block
END_COMMENT

# Multiple singles for readability
# -------------------------------
# Section: Database Backup
# -------------------------------
```

# **üìù Bash Variables: Short Notes with Examples**

## **‚úÖ VARIABLE BASICS**

### **1. Definition & Syntax**
```bash
variable_name="value"    # NO spaces around =
echo $variable_name      # Access with $
echo ${variable_name}    # Safer with braces
```

### **2. Your Example 1: Simple Variable**
```bash
name="bibitaji"
echo "Name is $name, and date is $(date)"
```
**Output:**
```
Name is bibitaji, and date is Thu Jan 18 15:30:45 IST 2024
```

### **3. Your Example 2: Read Input**
```bash
echo "enter the name: "
read username
echo "You entered $username"
```
**Output (if user types "John"):**
```
enter the name: 
John
You entered John
```

---

## **üéØ VARIABLE TYPES**

### **1. String Variables (Default)**
```bash
fruit="apple"
color="red"
echo "A $fruit is $color"
# Output: A apple is red
```

### **2. Integer Variables**
```bash
num1=10
num2=20
sum=$((num1 + num2))
echo "Sum: $sum"
# Output: Sum: 30
```

### **3. Read-only Variables**
```bash
readonly pi=3.14
pi=3.14159  # Error: readonly variable
```

---

## **üîß INPUT METHODS**

### **1. Simple `read`**
```bash
echo "Enter age:"
read age
echo "Age: $age"
```

### **2. `read` with Prompt (Your Example 2)**
```bash
read -p "Enter username: " username
echo "you entered $username"
sudo useradd -m $username
echo "New User added"
```
**Output:**
```
Enter username: jetha
you entered jetha
[sudo] password for shubham: 
New User added
```

### **3. Silent Input (Passwords)**
```bash
read -sp "Enter password: " pass
echo  # New line after hidden input
```

### **4. Multiple Variables**
```bash
read -p "Enter name and age: " name age
echo "$name is $age years old"
```

---

## **‚ö° SPECIAL VARIABLES**

| Variable | Purpose | Example Output |
|----------|---------|----------------|
| `$0` | Script name | `./script.sh` |
| `$1, $2...` | Arguments | `$1 = first arg` |
| `$#` | Argument count | `3` |
| `$@` | All arguments | `arg1 arg2 arg3` |
| `$?` | Exit status | `0` (success) |
| `$$` | Process ID | `12345` |

**Example:**
```bash
echo "Script: $0"
echo "First arg: $1"
echo "Total args: $#"
```
```bash
./script.sh hello world
# Output:
# Script: ./script.sh
# First arg: hello
# Total args: 2
```

---


---

## **‚ö†Ô∏è COMMON MISTAKES**

### **WRONG:**
```bash
name = "jetha"    # Spaces around =
echo name         # Missing $
```

### **RIGHT:**
```bash
name="jetha"      # No spaces
echo "$name"      # Use quotes for values
```

---



## **üéØ QUICK REFERENCE**

| Task | Syntax | Example |
|------|--------|---------|
| **Define** | `var=value` | `name="Jetha"` |
| **Access** | `$var` | `echo $name` |
| **Read input** | `read var` | `read username` |
| **Read with prompt** | `read -p "text" var` | `read -p "Enter: " val` |
| **Command output** | `$(command)` | `date=$(date)` |
| **Arithmetic** | `$((expr))` | `sum=$((a+b))` |

---

## **üîç TEST YOUR UNDERSTANDING**

**What will this output?**
```bash
greeting="Namaste"
target="Duniya"
echo "$greeting, $target!"
```
**Output:** `Namaste, Duniya!`

**What about this?**
```bash
read -p "Enter fruit: " fruit
count=5
echo "I have $count ${fruit}s"
```
**Output (if input="apple"):** `I have 5 apples`

# **üìù Bash Arguments **

## **‚úÖ BASIC ARGUMENT ACCESS**

### **Syntax:**
```bash
./script.sh arg1 arg2 arg3
# Inside script:
# $0 = script name
# $1 = arg1, $2 = arg2, $3 = arg3...
```

### **Example 1: Simple Arguments**
```bash
#!/bin/bash
echo "Script: $0"
echo "First: $1"
echo "Second: $2"
echo "Third: $3"
```
**Run & Output:**
```bash
./greet.sh Namaste Jetha Bhide
# Output:
# Script: ./greet.sh
# First: Namaste
# Second: Jetha
# Third: Bhide
```

---

## **üéØ SPECIAL ARGUMENT VARIABLES**

| Variable | Purpose | Example Output |
|----------|---------|----------------|
| `$0` | Script name | `./script.sh` |
| `$1-$9` | Arguments 1-9 | `arg1, arg2...` |
| `${10}-${n}` | Arguments 10+ | Use braces for >9 |
| `$#` | Total argument count | `3` |
| `$@` | All arguments as separate words | `arg1 arg2 arg3` |
| `$*` | All arguments as single string | `arg1 arg2 arg3` |
| `$?` | Exit status of last command | `0` (success) |
| `$$` | Current shell's process ID | `12345` |

---

## **üîß PRACTICAL EXAMPLES**

### **Example 2: User Creation Script**
```bash
#!/bin/bash
# Usage: ./adduser.sh username home_dir
echo "Creating user: $1"
sudo useradd -m -d /home/$2 $1
echo "User $1 created with home: /home/$2"
```
**Run & Output:**
```bash
./adduser.sh jetha /home/jetha_lal
# Output:
# Creating user: jetha
# [sudo password prompt]
# User jetha created with home: /home/jetha_lal
```

### **Example 3: File Backup Script**
```bash
#!/bin/bash
# Usage: ./backup.sh source.txt backup/
cp $1 $2/backup_$(date +%Y%m%d).txt
echo "Backup created: $2/backup_$(date +%Y%m%d).txt"
```
**Run & Output:**
```bash
./backup.sh important.txt backups/
# Output:
# Backup created: backups/backup_20240118.txt
```

---

## **üí° ADVANCED TECHNIQUES**

### **1. Shift Arguments**
```bash
#!/bin/bash
echo "First: $1"
shift  # Remove first argument
echo "Now first: $1"
echo "Total args left: $#"
```
**Run & Output:**
```bash
./shift.sh A B C
# Output:
# First: A
# Now first: B
# Total args left: 2
```

### **2. Loop Through All Arguments**
```bash
#!/bin/bash
echo "All arguments:"
for arg in "$@"
do
    echo "- $arg"
done
```
**Run & Output:**
```bash
./loop.sh apple banana cherry
# Output:
# All arguments:
# - apple
# - banana
# - cherry
```

### **3. Default Values**
```bash
#!/bin/bash
name=${1:-"Guest"}  # Default to "Guest" if no arg
age=${2:-20}        # Default to 20
echo "Hello $name, you are $age years old"
```
**Run & Output:**
```bash
./default.sh
# Output: Hello Guest, you are 20 years old

./default.sh Jetha 45
# Output: Hello Jetha, you are 45 years old
```

### **4. Check Minimum Arguments**
```bash
#!/bin/bash
if [ $# -lt 2 ]; then
    echo "Usage: $0 <name> <age>"
    exit 1
fi
echo "Name: $1, Age: $2"
```
**Run & Output:**
```bash
./check.sh
# Output: Usage: ./check.sh <name> <age>

./check.sh Babita 35
# Output: Name: Babita, Age: 35
```

---

## **‚ö†Ô∏è COMMON MISTAKES**

### **WRONG:**
```bash
echo $1$2$3    # If any arg has spaces: broken
echo $10       # This is $1 followed by 0, not $10!
```

### **RIGHT:**
```bash
echo "$1$2$3"  # Quotes protect spaces
echo "${10}"   # Use braces for arguments >9
```

---

## **üìä REAL-WORLD EXAMPLES**

### **Example 4: Calculator**
```bash
#!/bin/bash
# Usage: ./calc.sh 10 + 5
result=$(( $1 $2 $3 ))
echo "$1 $2 $3 = $result"
```
**Run & Output:**
```bash
./calc.sh 10 + 5
# Output: 10 + 5 = 15

./calc.sh 20 "*" 3  # Note: quote * to prevent globbing
# Output: 20 * 3 = 60
```

### **Example 5: File Search**
```bash
#!/bin/bash
# Usage: ./find.sh .txt /home/user
find $2 -name "*$1" -type f | head -5
echo "Found $(find $2 -name "*$1" -type f | wc -l) files"
```
**Run & Output:**
```bash
./find.sh .txt /home/jetha
# Output:
# /home/jetha/file1.txt
# /home/jetha/file2.txt
# Found 2 files
```

---

## **üéØ QUICK REFERENCE CARD**

| Task | Command | Example |
|------|---------|---------|
| **Access 1st arg** | `$1` | `echo "Hello $1"` |
| **Count args** | `$#` | `echo "Got $# args"` |
| **All args** | `$@` | `for arg in "$@"` |
| **Check if args exist** | `if [ $# -eq 0 ]` | `if [ $# -eq 0 ]; then` |
| **Set defaults** | `${1:-default}` | `name=${1:-"Anonymous"}` |
| **Shift args** | `shift` | `shift; echo "$1"` |

---

## **üîç TEST YOURSELF**

**Q1: What does this script output?**
```bash
#!/bin/bash
echo "$2 $1 $3"
```
**Run:** `./test.sh Hello Beautiful World`  
**Output:** `Beautiful Hello World`

**Q2: What does this output?**
```bash
#!/bin/bash
total=$#
echo "You passed $total arguments"
shift 2
echo "After shift: $# arguments left"
```
**Run:** `./test.sh A B C D`  
**Output:**
```
You passed 4 arguments
After shift: 2 arguments left
```

---

## **‚úÖ BEST PRACTICES**

1. **Always validate**: Check `$#` before using `$1`, `$2`, etc.
2. **Use quotes**: `"$@"` preserves argument boundaries
3. **Provide help**: Show usage when arguments missing
4. **Use defaults**: `${1:-default}` for optional args
5. **Clear names**: Use `source`, `dest` instead of just `$1`, `$2`

---

## **üöÄ MINI PROJECT: Argument Processor**

```bash
#!/bin/bash
# process.sh - Flexible argument handler

while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--name)
            name="$2"
            shift 2
            ;;
        -a|--age)
            age="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 -n name -a age"
            exit 0
            ;;
        *)
            echo "Unknown argument: $1"
            exit 1
            ;;
    esac
done

echo "Name: ${name:-Not specified}, Age: ${age:-Not specified}"
```

**Usage:**
```bash
./process.sh -n Jetha -a 45
# Output: Name: Jetha, Age: 45
```

---

# **üìù Bash Conditionals: Short Notes**

## **‚úÖ BASIC IF-THEN-ELSE**

### **Syntax:**
```bash
if [ condition ]; then
    # commands
elif [ condition ]; then
    # commands  
else
    # commands
fi
```

### **Example 1: Number Check**
```bash
#!/bin/bash
read -p "Enter a number: " num

if [ $num -gt 10 ]; then
    echo "$num is greater than 10"
elif [ $num -eq 10 ]; then
    echo "$num equals 10"
else
    echo "$num is less than 10"
fi
```
**Output:**
```bash
Enter a number: 15
# Output: 15 is greater than 10

Enter a number: 5  
# Output: 5 is less than 10
```

---

## **üéØ TEST OPERATORS**

### **1. Numeric Comparisons**
| Operator | Meaning | Example |
|----------|---------|---------|
| `-eq` | Equal | `[ $a -eq $b ]` |
| `-ne` | Not equal | `[ $a -ne $b ]` |
| `-gt` | Greater than | `[ $a -gt $b ]` |
| `-lt` | Less than | `[ $a -lt $b ]` |
| `-ge` | Greater or equal | `[ $a -ge $b ]` |
| `-le` | Less or equal | `[ $a -le $b ]` |

### **Example 2: Age Check**
```bash
#!/bin/bash
age=25

if [ $age -ge 18 ]; then
    echo "You can vote!"
else
    echo "Too young to vote"
fi
```
**Output:** `You can vote!`

---

### **2. String Comparisons**
| Operator | Meaning | Example |
|----------|---------|---------|
| `=` or `==` | Equal | `[ "$a" = "$b" ]` |
| `!=` | Not equal | `[ "$a" != "$b" ]` |
| `-z` | Empty string | `[ -z "$a" ]` |
| `-n` | Not empty | `[ -n "$a" ]` |
| `<` | Less than (ASCII) | `[[ "$a" < "$b" ]]` |
| `>` | Greater than | `[[ "$a" > "$b" ]]` |

### **Example 3: Username Check**
```bash
#!/bin/bash
read -p "Enter username: " username

if [ -z "$username" ]; then
    echo "Username cannot be empty!"
elif [ "$username" = "admin" ]; then
    echo "Welcome Administrator"
else
    echo "Hello $username"
fi
```
**Output:**
```bash
Enter username: admin
# Output: Welcome Administrator

Enter username: 
# Output: Username cannot be empty!
```

---

### **3. File Tests**
| Operator | Checks | Example |
|----------|--------|---------|
| `-e` | File exists | `[ -e file.txt ]` |
| `-f` | Regular file | `[ -f file.txt ]` |
| `-d` | Directory | `[ -d /home ]` |
| `-s` | File not empty | `[ -s data.txt ]` |
| `-r` | Readable | `[ -r file.txt ]` |
| `-w` | Writable | `[ -w file.txt ]` |
| `-x` | Executable | `[ -x script.sh ]` |

### **Example 4: File Operations**
```bash
#!/bin/bash
file="hello.txt"

if [ -f "$file" ]; then
    echo "$file exists"
    if [ -w "$file" ]; then
        echo "You can write to $file"
    fi
else
    echo "$file not found"
fi
```
**Output:**
```bash
# If hello.txt exists and is writable:
# hello.txt exists
# You can write to hello.txt
```

---

## **üîß CONDITIONAL VARIATIONS**

### **1. Case Statement (Switch-Case)**
```bash
#!/bin/bash
read -p "Enter fruit: " fruit

case $fruit in
    apple)
        echo "Red fruit"
        ;;
    banana)
        echo "Yellow fruit"
        ;;
    orange|mango)
        echo "Tropical fruit"
        ;;
    *)
        echo "Unknown fruit"
        ;;
esac
```
**Output:**
```bash
Enter fruit: apple
# Output: Red fruit

Enter fruit: mango
# Output: Tropical fruit
```

### **2. Logical Operators**
| Operator | Meaning | Example |
|----------|---------|---------|
| `&&` | AND | `[ $a -gt 0 ] && [ $a -lt 10 ]` |
| `||` | OR | `[ $a -eq 0 ] || [ $b -eq 0 ]` |
| `!` | NOT | `[ ! -f "$file" ]` |

### **Example 5: Complex Condition**
```bash
#!/bin/bash
read -p "Enter age: " age
read -p "Have ID? (yes/no): " has_id

if [ $age -ge 18 ] && [ "$has_id" = "yes" ]; then
    echo "Entry allowed"
elif [ $age -ge 18 ] && [ "$has_id" = "no" ]; then
    echo "Need ID proof"
else
    echo "Entry denied"
fi
```
**Output:**
```bash
Enter age: 20
Have ID? (yes/no): yes
# Output: Entry allowed
```

---

### **3. Double Brackets `[[ ]]` (Extended)**
- More features than `[ ]`
- Supports `&&`, `||` inside
- Pattern matching with `=~`

### **Example 6: Pattern Matching**
```bash
#!/bin/bash
email="user@example.com"

if [[ "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
    echo "Valid email"
else
    echo "Invalid email"
fi
```
**Output:** `Valid email`

---

### **4. Arithmetic Conditions `(( ))`**
```bash
#!/bin/bash
a=10
b=20

if (( a < b )); then
    echo "$a is less than $b"
fi

if (( (a + b) > 25 )); then
    echo "Sum is greater than 25"
fi
```
**Output:**
```
10 is less than 20
Sum is greater than 25
```

---

## **‚ö†Ô∏è COMMON PITFALLS**

### **WRONG:**
```bash
if [ $var = "text" ]    # Missing quotes if var empty
if [ $num > 10 ]        # > is redirection, not comparison
if [ $a == $b ]         # Single = for string in [ ]
```

### **RIGHT:**
```bash
if [ "$var" = "text" ]  # Always quote variables
if [ $num -gt 10 ]      # Use -gt for numbers
if [[ $a == $b ]]       # == works in [[ ]]
```

---

## **üìä PRACTICAL EXAMPLES**

### **Example 7: System Check Script**
```bash
#!/bin/bash
# system_check.sh

if [ $(whoami) = "root" ]; then
    echo "Running as root"
else
    echo "Run with sudo"
fi

if [ -d "/etc" ]; then
    echo "/etc directory exists"
fi

if [ -x "$(command -v git)" ]; then
    echo "Git is installed"
else
    echo "Git not found"
fi
```
**Output:**
```
Running as root
/etc directory exists  
Git is installed
```

### **Example 8: Backup Script with Conditions**
```bash
#!/bin/bash
source="$1"
dest="$2"

if [ $# -ne 2 ]; then
    echo "Usage: $0 source dest"
    exit 1
fi

if [ ! -e "$source" ]; then
    echo "Error: $source not found"
    exit 1
fi

if [ -e "$dest" ]; then
    read -p "$dest exists. Overwrite? (y/n): " choice
    if [ "$choice" != "y" ]; then
        echo "Backup cancelled"
        exit 0
    fi
fi

cp -r "$source" "$dest"
echo "Backup completed"
```

---

## **üéØ QUICK REFERENCE**

| Task | Syntax | Example |
|------|--------|---------|
| **Basic if** | `if [ ]; then` | `if [ -f file ]; then` |
| **If-else** | `if [ ]; then else fi` | `if [ $x -eq 1 ]; then echo "yes"; else echo "no"; fi` |
| **Case** | `case $var in pattern) ;; esac` | `case $fruit in apple) ;; esac` |
| **AND** | `&&` or `-a` | `[ $a -gt 0 ] && [ $b -gt 0 ]` |
| **OR** | `||` or `-o` | `[ $a -eq 0 ] || [ $b -eq 0 ]` |
| **File exists** | `-e` | `if [ -e file.txt ]; then` |
| **String empty** | `-z` | `if [ -z "$name" ]; then` |

---

## **üîç TEST YOURSELF**

**Q1: What's the output?**
```bash
x=5
y=10
if [ $x -lt $y ] && [ $y -gt 8 ]; then
    echo "Pass"
else
    echo "Fail"
fi
```
**Output:** `Pass`

**Q2: Fix this buggy code:**
```bash
if [ $USER = root ]; then
    echo "You are root"
fi
```
**Fixed:**
```bash
if [ "$USER" = "root" ]; then
    echo "You are root"
fi
```

---

## **‚úÖ BEST PRACTICES**

1. **Quote variables**: `"$var"` prevents empty variable errors
2. **Use `[[ ]]`** for advanced features (regex, pattern matching)
3. **Use `(( ))`** for arithmetic operations
4. **Indent code** for readability
5. **Add comments** for complex conditions
6. **Test edge cases**: empty strings, special characters

---

## **üöÄ MINI PROJECT: Grade Calculator**

```bash
#!/bin/bash
read -p "Enter marks (0-100): " marks

if (( marks >= 90 && marks <= 100 )); then
    grade="A+"
elif (( marks >= 80 )); then
    grade="A"
elif (( marks >= 70 )); then
    grade="B"
elif (( marks >= 60 )); then
    grade="C"
elif (( marks >= 50 )); then
    grade="D"
elif (( marks >= 0 )); then
    grade="F"
else
    echo "Invalid marks"
    exit 1
fi

echo "Marks: $marks, Grade: $grade"

# Additional check
if [[ "$grade" == "F" ]]; then
    echo "You need to improve!"
fi
```

**Output:**
```bash
Enter marks (0-100): 85
# Output: Marks: 85, Grade: A
```

---

# **üìù Bash Loops: Short Notes**

## **‚úÖ FOR LOOPS**

### **1. Basic For Loop**
```bash
for variable in list; do
    # commands
done
```

### **Example 1: Iterate List**
```bash
#!/bin/bash
for fruit in apple banana cherry mango; do
    echo "I like $fruit"
done
```
**Output:**
```
I like apple
I like banana  
I like cherry
I like mango
```

### **2. Iterate Over Files**
```bash
#!/bin/bash
for file in *.txt; do
    echo "Processing: $file"
    wc -l "$file"
done
```
**Output:**
```
Processing: notes.txt
5 notes.txt
Processing: data.txt
10 data.txt
```

---

## **üéØ WHILE LOOPS**

### **Syntax:**
```bash
while [ condition ]; do
    # commands
done
```

### **Example 2: Countdown**
```bash
#!/bin/bash
count=5
while [ $count -gt 0 ]; do
    echo "Count: $count"
    sleep 1
    count=$((count - 1))
done
echo "Blast off!"
```
**Output:**
```
Count: 5
Count: 4
Count: 3  
Count: 2
Count: 1
Blast off!
```

### **Example 3: Read File Line by Line**
```bash
#!/bin/bash
while read line; do
    echo "Line: $line"
done < data.txt
```
**Output (if data.txt has 3 lines):**
```
Line: First line
Line: Second line  
Line: Third line
```

---

## **üîß UNTIL LOOPS**

### **Syntax:** (Runs UNTIL condition becomes true)
```bash
until [ condition ]; do
    # commands
done
```

### **Example 4: Wait for Service**
```bash
#!/bin/bash
counter=1
until [ $counter -gt 3 ]; do
    echo "Attempt $counter: Checking service..."
    # ping -c1 server &>/dev/null && break
    sleep 2
    counter=$((counter + 1))
done
echo "Done checking"
```
**Output:**
```
Attempt 1: Checking service...
Attempt 2: Checking service...
Attempt 3: Checking service...
Done checking
```

---

## **‚ö° LOOP VARIATIONS & TRICKS**

### **1. C-style For Loop**
```bash
#!/bin/bash
for ((i=1; i<=5; i++)); do
    echo "Iteration $i"
done
```
**Output:**
```
Iteration 1
Iteration 2
Iteration 3
Iteration 4
Iteration 5
```

### **2. Infinite Loop**
```bash
#!/bin/bash
while true; do
    echo "Press Ctrl+C to stop"
    sleep 2
done
```

### **3. Loop with Continue**
```bash
#!/bin/bash
for i in {1..10}; do
    if [ $((i % 2)) -eq 0 ]; then
        continue  # Skip even numbers
    fi
    echo "Odd: $i"
done
```
**Output:**
```
Odd: 1
Odd: 3
Odd: 5
Odd: 7
Odd: 9
```

### **4. Loop with Break**
```bash
#!/bin/bash
for i in {1..10}; do
    echo "Number: $i"
    if [ $i -eq 5 ]; then
        echo "Stopping at 5"
        break
    fi
done
```
**Output:**
```
Number: 1
Number: 2
Number: 3
Number: 4
Number: 5
Stopping at 5
```

---

## **üí° PRACTICAL EXAMPLES**

### **Example 5: Backup Multiple Files**
```bash
#!/bin/bash
# backup_files.sh
files=("/etc/passwd" "/etc/hosts" "/var/log/syslog")

for file in "${files[@]}"; do
    if [ -f "$file" ]; then
        cp "$file" "/backup/$(basename "$file").bak"
        echo "Backed up: $file"
    else
        echo "Warning: $file not found"
    fi
done
```

### **Example 6: User Management**
```bash
#!/bin/bash
# add_users.sh
usernames=("jetha" "babitaji" "iyer" "hathi")

for user in "${usernames[@]}"; do
    if id "$user" &>/dev/null; then
        echo "User $user already exists"
    else
        sudo useradd -m "$user"
        echo "Created user: $user"
    fi
done
```

### **Example 7: Process Monitor**
```bash
#!/bin/bash
# monitor.sh
process="nginx"
attempts=0

until pgrep -x "$process" >/dev/null; do
    echo "$process not running. Attempt $((attempts+1))"
    attempts=$((attempts + 1))
    
    if [ $attempts -eq 3 ]; then
        echo "Starting $process..."
        sudo systemctl start "$process"
    elif [ $attempts -ge 5 ]; then
        echo "Failed to start $process"
        exit 1
    fi
    sleep 3
done

echo "$process is running!"
```

---

## **‚ö†Ô∏è COMMON PITFALLS**

### **WRONG:**
```bash
for file in $(ls *.txt)     # Breaks with spaces in filenames
while read line              # Issues with leading/trailing spaces
for i in {1..$max}          # Brace expansion before variable
```

### **RIGHT:**
```bash
for file in *.txt           # Use glob directly
while IFS= read -r line     # Preserve spaces
for ((i=1; i<=max; i++))    # C-style for variables
```

---

## **üìä LOOP CONTROL STATEMENTS**

| Statement | Effect | Example |
|-----------|--------|---------|
| `break` | Exit loop | `break` or `break 2` (exit 2 levels) |
| `continue` | Skip to next iteration | `continue` |
| `exit` | Exit entire script | `exit 1` (with error code) |

### **Example 8: Nested Loops with Break**
```bash
#!/bin/bash
for i in {1..3}; do
    echo "Outer loop: $i"
    for j in {1..3}; do
        echo "  Inner loop: $j"
        if [ $j -eq 2 ]; then
            break 2  # Break out of 2 levels
        fi
    done
done
```
**Output:**
```
Outer loop: 1
  Inner loop: 1
  Inner loop: 2
# Loop stops here due to break 2
```

---

## **üéØ SPECIAL LOOP SYNTAX**

### **1. Brace Expansion**
```bash
for i in {1..5}; do echo $i; done
for i in {01..10}; do echo $i; done  # Zero-padded
for i in {A..E}; do echo $i; done    # Letters
```

### **2. Sequence Command**
```bash
for i in $(seq 1 2 10); do           # 1 to 10 step 2
    echo $i
done
# Output: 1 3 5 7 9
```

### **3. Command Output**
```bash
for user in $(cut -d: -f1 /etc/passwd | head -5); do
    echo "User: $user"
done
```

### **4. Array Iteration**
```bash
colors=("red" "green" "blue")
for color in "${colors[@]}"; do
    echo "Color: $color"
done
```

---

## **üîç REAL-WORLD USE CASES**

### **Case 1: Log Rotation**
```bash
#!/bin/bash
# rotate_logs.sh
log_dir="/var/log/myapp"
days_to_keep=7

for logfile in "$log_dir"/*.log; do
    if [ -f "$logfile" ]; then
        if find "$logfile" -mtime +$days_to_keep | grep -q .; then
            echo "Archiving: $logfile"
            gzip "$logfile"
        fi
    fi
done
```

### **Case 2: Bulk Image Processing**
```bash
#!/bin/bash
# convert_images.sh
counter=1
for image in *.jpg *.png; do
    if [ -f "$image" ]; then
        new_name="image_$(printf "%03d" $counter).jpg"
        convert "$image" -resize 800x600 "$new_name"
        echo "Converted: $image -> $new_name"
        counter=$((counter + 1))
    fi
done
```

### **Case 3: Ping Multiple Hosts**
```bash
#!/bin/bash
# network_check.sh
hosts=("google.com" "github.com" "example.com")

for host in "${hosts[@]}"; do
    if ping -c 1 "$host" &>/dev/null; then
        echo "‚úÖ $host is reachable"
    else
        echo "‚ùå $host is down"
    fi
done
```

---

## **‚úÖ BEST PRACTICES**

1. **Quote variables** in loops: `"$var"`
2. **Use `-r` with `read`** to preserve backslashes
3. **Set `IFS`** for specific delimiter needs
4. **Avoid `for i in $(ls)`** - use glob patterns instead
5. **Add error handling** inside loops
6. **Use meaningful variable names** (not just i, j)

---

## **üöÄ MINI PROJECT: Password Generator**

```bash
#!/bin/bash
# generate_passwords.sh
read -p "How many passwords? " count
read -p "Password length? " length

echo "Generating $count passwords of length $length..."
echo "=============================="

for ((i=1; i<=count; i++)); do
    password=$(tr -dc 'A-Za-z0-9!@#$%' < /dev/urandom | head -c $length)
    echo "$i: $password"
    
    # Strength check
    if [[ ${#password} -ge 12 ]] && [[ "$password" =~ [A-Z] ]] && \
       [[ "$password" =~ [0-9] ]] && [[ "$password" =~ [!@#$%] ]]; then
        echo "   [STRONG]"
    else
        echo "   [WEAK]"
    fi
done
```

**Output:**
```
How many passwords? 3
Password length? 10
Generating 3 passwords of length 10...
==============================
1: aB3$fG7!kL
   [STRONG]
2: abcdefghij
   [WEAK]
3: 123!@#qWeR
   [STRONG]
```

---

## **üìã QUICK REFERENCE**

| Loop Type | When to Use | Example |
|-----------|-------------|---------|
| `for` | Known iterations | `for file in *.txt` |
| `while` | Condition-based | `while [ $x -lt 10 ]` |
| `until` | Run until true | `until service is up` |
| `C-style` | Numeric ranges | `for ((i=0; i<10; i++))` |

---

## **üîç TEST YOURSELF**

**Q1: What's the output?**
```bash
for i in {1..3}; do
    for j in {1..2}; do
        echo "$i-$j"
    done
done
```
**Output:**
```
1-1
1-2
2-1
2-2
3-1
3-2
```

**Q2: Fix this infinite loop:**
```bash
x=1
while [ $x -lt 5 ]; do
    echo "Number: $x"
done
```
**Fixed:**
```bash
x=1
while [ $x -lt 5 ]; do
    echo "Number: $x"
    x=$((x + 1))
done
```

---

# **üìù Bash Functions: Short Notes**

## **‚úÖ FUNCTION BASICS**

### **Syntax:**
```bash
function_name() {
    # commands
    return value
}
```

### **Example 1: Simple Function**
```bash
#!/bin/bash
# Define
greet() {
    echo "Hello, $1!"
}

# Call
greet "Jetha"
greet "Babitaji"
```
**Output:**
```
Hello, Jetha!
Hello, Babitaji!
```

---

## **üéØ FUNCTION VARIATIONS**

### **1. Function with Return Value**
```bash
#!/bin/bash
add() {
    local sum=$(( $1 + $2 ))
    return $sum
}

add 10 20
result=$?
echo "Sum: $result"
```
**Output:** `Sum: 30`

### **2. Function that Returns String**
```bash
#!/bin/bash
get_hostname() {
    echo "$(hostname)-$(date +%Y%m%d)"
}

server=$(get_hostname)
echo "Server: $server"
```
**Output:**
```
Server: shubham-mbp-20240118
```

---

## **üîß FUNCTION PARAMETERS**

### **Accessing Parameters:**
- `$1, $2, ...` = Function arguments
- `$#` = Number of arguments
- `$@` = All arguments
- `$*` = All arguments as one string

### **Example 2: Parameterized Function**
```bash
#!/bin/bash
user_info() {
    echo "Username: $1"
    echo "Age: $2"
    echo "City: $3"
    echo "Total args: $#"
}

user_info "Jethalal" 45 "Mumbai"
```
**Output:**
```
Username: Jethalal
Age: 45
City: Mumbai
Total args: 3
```

---

## **üí° PRACTICAL EXAMPLES**

### **Example 3: File Backup Function**
```bash
#!/bin/bash
backup_file() {
    local src=$1
    local dest=${2:-"/backup"}  # Default backup directory
    
    if [ ! -f "$src" ]; then
        echo "Error: $src not found"
        return 1
    fi
    
    local backup_name="$(basename "$src").$(date +%Y%m%d).bak"
    cp "$src" "$dest/$backup_name"
    echo "Backup created: $dest/$backup_name"
    return 0
}

# Usage
backup_file "/etc/hosts"
backup_file "/etc/passwd" "/mybackups"
```
**Output:**
```
Backup created: /backup/hosts.20240118.bak
Backup created: /mybackups/passwd.20240118.bak
```

### **Example 4: System Check Functions**
```bash
#!/bin/bash
check_disk() {
    local usage=$(df -h / | awk 'NR==2 {print $5}' | tr -d '%')
    echo "Disk usage: $usage%"
    [ $usage -gt 80 ] && return 1 || return 0
}

check_memory() {
    local free_mem=$(free -m | awk 'NR==2 {print $4}')
    echo "Free memory: ${free_mem}MB"
    [ $free_mem -lt 500 ] && return 1 || return 0
}

# Call checks
check_disk
disk_status=$?

check_memory
memory_status=$?

if [ $disk_status -eq 0 ] && [ $memory_status -eq 0 ]; then
    echo "System is healthy"
else
    echo "System check failed"
fi
```

---

## **‚ö° ADVANCED FEATURES**

### **1. Local Variables**
```bash
#!/bin/bash
calculate() {
    local x=$1
    local y=$2
    local result=$((x * y + 10))
    echo $result
}

output=$(calculate 5 3)
echo "Output: $output"  # Output: 25
```

### **2. Return vs Echo**
```bash
#!/bin/bash
# WRONG: Returning strings via return
get_name() {
    return "Jetha"  # ERROR: return only takes 0-255
}

# RIGHT: Use echo for strings
get_name() {
    echo "Jethalal Gada"
}

name=$(get_name)
echo "Name: $name"
```

### **3. Function from Another Script**
**utils.sh:**
```bash
#!/bin/bash
# Utility functions
log_info() {
    echo "[INFO] $(date): $1"
}

log_error() {
    echo "[ERROR] $(date): $1" >&2
}
```

**main.sh:**
```bash
#!/bin/bash
source utils.sh

log_info "Starting backup..."
# Do backup
log_info "Backup completed"
log_error "Failed to copy file"
```

---

## **üîÑ RECURSIVE FUNCTIONS**

### **Example 5: Factorial**
```bash
#!/bin/bash
factorial() {
    local n=$1
    if [ $n -le 1 ]; then
        echo 1
    else
        local prev=$(factorial $((n-1)))
        echo $((n * prev))
    fi
}

echo "Factorial 5: $(factorial 5)"
```
**Output:** `Factorial 5: 120`

### **Example 6: Directory Tree**
```bash
#!/bin/bash
list_tree() {
    local indent=$1
    local dir=$2
    
    for item in "$dir"/*; do
        echo "${indent}‚îú‚îÄ‚îÄ $(basename "$item")"
        if [ -d "$item" ]; then
            list_tree "${indent}    " "$item"
        fi
    done
}

list_tree "" "."
```

---

## **üéØ SPECIAL FUNCTION TYPES**

### **1. Anonymous Functions (Subshell)**
```bash
#!/bin/bash
result=$( 
    # This is like an anonymous function
    a=10
    b=20
    echo $((a + b))
)
echo "Result: $result"  # Output: 30
```

### **2. Function with Default Arguments**
```bash
#!/bin/bash
connect() {
    local host=${1:-"localhost"}
    local port=${2:-"8080"}
    local timeout=${3:-"30"}
    
    echo "Connecting to $host:$port (timeout: ${timeout}s)"
    # Connection logic here
}

connect  # Uses defaults
connect "example.com" 443
```

### **3. Function that Creates Functions**
```bash
#!/bin/bash
create_greeter() {
    local name=$1
    eval "${name}_greet() { echo \"Hello from $name!\"; }"
}

create_greeter "Jetha"
create_greeter "Babitaji"

Jetha_greet  # Output: Hello from Jetha!
Babitaji_greet  # Output: Hello from Babitaji!
```

---

## **‚ö†Ô∏è COMMON PITFALLS**

### **WRONG:**
```bash
function add {  # Missing parentheses
    sum=$1+$2  # String concatenation
    return $sum  # Can't return >255
}

add() {
    result=$1 + $2  # Spaces cause error
}
```

### **RIGHT:**
```bash
add() {
    local sum=$(( $1 + $2 ))
    echo $sum  # Return via echo for >255
}

result=$(add 100 200)  # Capture output
```

---

## **üìä REAL-WORLD USE CASES**

### **Case 1: Database Operations**
```bash
#!/bin/bash
db_connect() {
    local db=${1:-"testdb"}
    echo "Connecting to $db..."
    # MySQL/Postgres connection logic
}

db_query() {
    local query=$1
    echo "Executing: $query"
    # Execute query and return results
}

db_backup() {
    local db=$1
    local backup_file="${db}_$(date +%Y%m%d).sql"
    echo "Backing up $db to $backup_file"
    # mysqldump or pg_dump logic
    echo "Backup complete"
}

# Usage
db_connect "inventory"
db_backup "inventory"
result=$(db_query "SELECT COUNT(*) FROM products")
```

### **Case 2: API Client**
```bash
#!/bin/bash
api_get() {
    local endpoint=$1
    curl -s -X GET "https://api.example.com/$endpoint"
}

api_post() {
    local endpoint=$1
    local data=$2
    curl -s -X POST "https://api.example.com/$endpoint" \
         -H "Content-Type: application/json" \
         -d "$data"
}

# Usage
users=$(api_get "users")
echo "Creating user..."
response=$(api_post "users" '{"name":"Jetha","age":45}')
```

### **Case 3: Logging Framework**
```bash
#!/bin/bash
LOG_FILE="/var/log/myapp.log"

log() {
    local level=$1
    local message=$2
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] $message" | tee -a "$LOG_FILE"
}

debug() { log "DEBUG" "$1"; }
info() { log "INFO" "$1"; }
warn() { log "WARN" "$1"; }
error() { log "ERROR" "$1"; }

# Usage
info "Application started"
debug "User logged in: $USER"
error "Failed to connect to database"
```

---

## **‚úÖ BEST PRACTICES**

1. **Use `local`** for function variables
2. **Return 0 for success**, non-zero for errors
3. **Use `echo` for string output**, `return` for status codes
4. **Validate parameters** at function start
5. **Keep functions small and focused** (single responsibility)
6. **Document with comments** at function header
7. **Source reusable functions** from separate files

---

## **üöÄ MINI PROJECT: Calculator with Functions**

```bash
#!/bin/bash
# calculator.sh

show_menu() {
    echo "Calculator Menu:"
    echo "1. Add"
    echo "2. Subtract"
    echo "3. Multiply"
    echo "4. Divide"
    echo "5. Exit"
}

add() {
    echo "Result: $(( $1 + $2 ))"
}

subtract() {
    echo "Result: $(( $1 - $2 ))"
}

multiply() {
    echo "Result: $(( $1 * $2 ))"
}

divide() {
    if [ $2 -eq 0 ]; then
        echo "Error: Division by zero!"
        return 1
    fi
    echo "Result: $(( $1 / $2 ))"
    echo "Remainder: $(( $1 % $2 ))"
}

while true; do
    show_menu
    read -p "Choose operation (1-5): " choice
    
    case $choice in
        1|2|3|4)
            read -p "Enter first number: " num1
            read -p "Enter second number: " num2
            
            case $choice in
                1) add $num1 $num2 ;;
                2) subtract $num1 $num2 ;;
                3) multiply $num1 $num2 ;;
                4) divide $num1 $num2 ;;
            esac
            ;;
        5)
            echo "Goodbye!"
            exit 0
            ;;
        *)
            echo "Invalid choice!"
            ;;
    esac
    
    echo "----------------------"
done
```

**Output:**
```
Calculator Menu:
1. Add
2. Subtract
3. Multiply
4. Divide
5. Exit
Choose operation (1-5): 1
Enter first number: 10
Enter second number: 20
Result: 30
----------------------
```

---

## **üìã QUICK REFERENCE**

| Task | Syntax | Example |
|------|--------|---------|
| **Define** | `name() { }` | `greet() { echo "Hi"; }` |
| **Call** | `name args` | `greet "Jetha"` |
| **Local var** | `local var=value` | `local count=0` |
| **Return** | `return value` | `return 0` |
| **Capture output** | `var=$(func)` | `result=$(add 1 2)` |
| **Source functions** | `source file.sh` | `source utils.sh` |

---

## **üîç TEST YOURSELF**

**Q1: What's the output?**
```bash
#!/bin/bash
mystery() {
    local x=$1
    echo $((x * 2))
}

result=$(mystery 5)
echo "Double: $result"
```
**Output:** `Double: 10`

**Q2: Fix this function:**
```bash
#!/bin/bash
get_date() {
    return $(date +%Y%m%d)
}
```
**Fixed:**
```bash
#!/bin/bash
get_date() {
    echo $(date +%Y%m%d)
}

today=$(get_date)
echo "Today: $today"
```

---

## **üéØ PRO TIPS**

1. **Debug functions** with `set -x` inside function
2. **Use trap** with functions for cleanup
3. **Pass arrays** by name reference (bash 4.3+)
4. **Export functions** with `export -f` for subshells
5. **Autocomplete** can be added to functions

**Example: Export function**
```bash
#!/bin/bash
myfunc() { echo "I work in subshells!"; }
export -f myfunc

# Now works in subshells
bash -c "myfunc"
```

---

**Functions make your scripts modular, reusable, and maintainable. Master them!** üöÄ
