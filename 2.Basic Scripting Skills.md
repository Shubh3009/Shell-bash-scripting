# Day2 - Basic Scripting Skills
# **üìù Bash Comments**

## **‚úÖ SINGLE-LINE COMMENT**

### **Syntax:**
```bash
# Your comment here
```

### **Usage:**
```bash
# This is a full line comment
echo "Hello"  # This is an inline comment
# echo "This won't run"
```

### **Key Points:**
- Starts with `#`
- Ends at line end
- Can be anywhere on line
- **Ignored by shell completely**

---

## **‚úÖ MULTI-LINE COMMENT**

### **Method 1: Multiple Single Lines (Most Common)**
```bash
# Line 1 of comment
# Line 2 of comment
# Line 3 of comment
```

### **Method 2: Heredoc Trick (Block Comment)**
```bash
: << 'COMMENT'
This is a 
multi-line
comment block
COMMENT
```

**Or shorter:**
```bash
<< 'COMMENT' 2>/dev/null
Multi-line text
COMMENT
```

### **Method 3: Function Never Called**
```bash
__comment() {
    This is a 
    multi-line comment
    inside unused function
}
```


### **Wrong:**
```bash
<< COMMENT
echo "This might still execute!"
COMMENT
# Missing command before <<
```

### **Right:**
```bash
: << 'COMMENT'
echo "This won't execute"
COMMENT
```

---



---

## **üìã Summary **

```bash
# Single line comment

: << 'END_COMMENT'
Multi-line
comment block
END_COMMENT

# Multiple singles for readability
# -------------------------------
# Section: Database Backup
# -------------------------------
```

# **üìù Bash Variables: Short Notes with Examples**

## **‚úÖ VARIABLE BASICS**

### **1. Definition & Syntax**
```bash
variable_name="value"    # NO spaces around =
echo $variable_name      # Access with $
echo ${variable_name}    # Safer with braces
```

### **2. Your Example 1: Simple Variable**
```bash
name="bibitaji"
echo "Name is $name, and date is $(date)"
```
**Output:**
```
Name is bibitaji, and date is Thu Jan 18 15:30:45 IST 2024
```

### **3. Your Example 2: Read Input**
```bash
echo "enter the name: "
read username
echo "You entered $username"
```
**Output (if user types "John"):**
```
enter the name: 
John
You entered John
```

---

## **üéØ VARIABLE TYPES**

### **1. String Variables (Default)**
```bash
fruit="apple"
color="red"
echo "A $fruit is $color"
# Output: A apple is red
```

### **2. Integer Variables**
```bash
num1=10
num2=20
sum=$((num1 + num2))
echo "Sum: $sum"
# Output: Sum: 30
```

### **3. Read-only Variables**
```bash
readonly pi=3.14
pi=3.14159  # Error: readonly variable
```

---

## **üîß INPUT METHODS**

### **1. Simple `read`**
```bash
echo "Enter age:"
read age
echo "Age: $age"
```

### **2. `read` with Prompt (Your Example 2)**
```bash
read -p "Enter username: " username
echo "you entered $username"
sudo useradd -m $username
echo "New User added"
```
**Output:**
```
Enter username: jetha
you entered jetha
[sudo] password for shubham: 
New User added
```

### **3. Silent Input (Passwords)**
```bash
read -sp "Enter password: " pass
echo  # New line after hidden input
```

### **4. Multiple Variables**
```bash
read -p "Enter name and age: " name age
echo "$name is $age years old"
```

---

## **‚ö° SPECIAL VARIABLES**

| Variable | Purpose | Example Output |
|----------|---------|----------------|
| `$0` | Script name | `./script.sh` |
| `$1, $2...` | Arguments | `$1 = first arg` |
| `$#` | Argument count | `3` |
| `$@` | All arguments | `arg1 arg2 arg3` |
| `$?` | Exit status | `0` (success) |
| `$$` | Process ID | `12345` |

**Example:**
```bash
echo "Script: $0"
echo "First arg: $1"
echo "Total args: $#"
```
```bash
./script.sh hello world
# Output:
# Script: ./script.sh
# First arg: hello
# Total args: 2
```

---


---

## **‚ö†Ô∏è COMMON MISTAKES**

### **WRONG:**
```bash
name = "jetha"    # Spaces around =
echo name         # Missing $
```

### **RIGHT:**
```bash
name="jetha"      # No spaces
echo "$name"      # Use quotes for values
```

---



## **üéØ QUICK REFERENCE**

| Task | Syntax | Example |
|------|--------|---------|
| **Define** | `var=value` | `name="Jetha"` |
| **Access** | `$var` | `echo $name` |
| **Read input** | `read var` | `read username` |
| **Read with prompt** | `read -p "text" var` | `read -p "Enter: " val` |
| **Command output** | `$(command)` | `date=$(date)` |
| **Arithmetic** | `$((expr))` | `sum=$((a+b))` |

---

## **üîç TEST YOUR UNDERSTANDING**

**What will this output?**
```bash
greeting="Namaste"
target="Duniya"
echo "$greeting, $target!"
```
**Output:** `Namaste, Duniya!`

**What about this?**
```bash
read -p "Enter fruit: " fruit
count=5
echo "I have $count ${fruit}s"
```
**Output (if input="apple"):** `I have 5 apples`

# **üìù Bash Arguments **

## **‚úÖ BASIC ARGUMENT ACCESS**

### **Syntax:**
```bash
./script.sh arg1 arg2 arg3
# Inside script:
# $0 = script name
# $1 = arg1, $2 = arg2, $3 = arg3...
```

### **Example 1: Simple Arguments**
```bash
#!/bin/bash
echo "Script: $0"
echo "First: $1"
echo "Second: $2"
echo "Third: $3"
```
**Run & Output:**
```bash
./greet.sh Namaste Jetha Bhide
# Output:
# Script: ./greet.sh
# First: Namaste
# Second: Jetha
# Third: Bhide
```

---

## **üéØ SPECIAL ARGUMENT VARIABLES**

| Variable | Purpose | Example Output |
|----------|---------|----------------|
| `$0` | Script name | `./script.sh` |
| `$1-$9` | Arguments 1-9 | `arg1, arg2...` |
| `${10}-${n}` | Arguments 10+ | Use braces for >9 |
| `$#` | Total argument count | `3` |
| `$@` | All arguments as separate words | `arg1 arg2 arg3` |
| `$*` | All arguments as single string | `arg1 arg2 arg3` |
| `$?` | Exit status of last command | `0` (success) |
| `$$` | Current shell's process ID | `12345` |

---

## **üîß PRACTICAL EXAMPLES**

### **Example 2: User Creation Script**
```bash
#!/bin/bash
# Usage: ./adduser.sh username home_dir
echo "Creating user: $1"
sudo useradd -m -d /home/$2 $1
echo "User $1 created with home: /home/$2"
```
**Run & Output:**
```bash
./adduser.sh jetha /home/jetha_lal
# Output:
# Creating user: jetha
# [sudo password prompt]
# User jetha created with home: /home/jetha_lal
```

### **Example 3: File Backup Script**
```bash
#!/bin/bash
# Usage: ./backup.sh source.txt backup/
cp $1 $2/backup_$(date +%Y%m%d).txt
echo "Backup created: $2/backup_$(date +%Y%m%d).txt"
```
**Run & Output:**
```bash
./backup.sh important.txt backups/
# Output:
# Backup created: backups/backup_20240118.txt
```

---

## **üí° ADVANCED TECHNIQUES**

### **1. Shift Arguments**
```bash
#!/bin/bash
echo "First: $1"
shift  # Remove first argument
echo "Now first: $1"
echo "Total args left: $#"
```
**Run & Output:**
```bash
./shift.sh A B C
# Output:
# First: A
# Now first: B
# Total args left: 2
```

### **2. Loop Through All Arguments**
```bash
#!/bin/bash
echo "All arguments:"
for arg in "$@"
do
    echo "- $arg"
done
```
**Run & Output:**
```bash
./loop.sh apple banana cherry
# Output:
# All arguments:
# - apple
# - banana
# - cherry
```

### **3. Default Values**
```bash
#!/bin/bash
name=${1:-"Guest"}  # Default to "Guest" if no arg
age=${2:-20}        # Default to 20
echo "Hello $name, you are $age years old"
```
**Run & Output:**
```bash
./default.sh
# Output: Hello Guest, you are 20 years old

./default.sh Jetha 45
# Output: Hello Jetha, you are 45 years old
```

### **4. Check Minimum Arguments**
```bash
#!/bin/bash
if [ $# -lt 2 ]; then
    echo "Usage: $0 <name> <age>"
    exit 1
fi
echo "Name: $1, Age: $2"
```
**Run & Output:**
```bash
./check.sh
# Output: Usage: ./check.sh <name> <age>

./check.sh Babita 35
# Output: Name: Babita, Age: 35
```

---

## **‚ö†Ô∏è COMMON MISTAKES**

### **WRONG:**
```bash
echo $1$2$3    # If any arg has spaces: broken
echo $10       # This is $1 followed by 0, not $10!
```

### **RIGHT:**
```bash
echo "$1$2$3"  # Quotes protect spaces
echo "${10}"   # Use braces for arguments >9
```

---

## **üìä REAL-WORLD EXAMPLES**

### **Example 4: Calculator**
```bash
#!/bin/bash
# Usage: ./calc.sh 10 + 5
result=$(( $1 $2 $3 ))
echo "$1 $2 $3 = $result"
```
**Run & Output:**
```bash
./calc.sh 10 + 5
# Output: 10 + 5 = 15

./calc.sh 20 "*" 3  # Note: quote * to prevent globbing
# Output: 20 * 3 = 60
```

### **Example 5: File Search**
```bash
#!/bin/bash
# Usage: ./find.sh .txt /home/user
find $2 -name "*$1" -type f | head -5
echo "Found $(find $2 -name "*$1" -type f | wc -l) files"
```
**Run & Output:**
```bash
./find.sh .txt /home/jetha
# Output:
# /home/jetha/file1.txt
# /home/jetha/file2.txt
# Found 2 files
```

---

## **üéØ QUICK REFERENCE CARD**

| Task | Command | Example |
|------|---------|---------|
| **Access 1st arg** | `$1` | `echo "Hello $1"` |
| **Count args** | `$#` | `echo "Got $# args"` |
| **All args** | `$@` | `for arg in "$@"` |
| **Check if args exist** | `if [ $# -eq 0 ]` | `if [ $# -eq 0 ]; then` |
| **Set defaults** | `${1:-default}` | `name=${1:-"Anonymous"}` |
| **Shift args** | `shift` | `shift; echo "$1"` |

---

## **üîç TEST YOURSELF**

**Q1: What does this script output?**
```bash
#!/bin/bash
echo "$2 $1 $3"
```
**Run:** `./test.sh Hello Beautiful World`  
**Output:** `Beautiful Hello World`

**Q2: What does this output?**
```bash
#!/bin/bash
total=$#
echo "You passed $total arguments"
shift 2
echo "After shift: $# arguments left"
```
**Run:** `./test.sh A B C D`  
**Output:**
```
You passed 4 arguments
After shift: 2 arguments left
```

---

## **‚úÖ BEST PRACTICES**

1. **Always validate**: Check `$#` before using `$1`, `$2`, etc.
2. **Use quotes**: `"$@"` preserves argument boundaries
3. **Provide help**: Show usage when arguments missing
4. **Use defaults**: `${1:-default}` for optional args
5. **Clear names**: Use `source`, `dest` instead of just `$1`, `$2`

---

## **üöÄ MINI PROJECT: Argument Processor**

```bash
#!/bin/bash
# process.sh - Flexible argument handler

while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--name)
            name="$2"
            shift 2
            ;;
        -a|--age)
            age="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 -n name -a age"
            exit 0
            ;;
        *)
            echo "Unknown argument: $1"
            exit 1
            ;;
    esac
done

echo "Name: ${name:-Not specified}, Age: ${age:-Not specified}"
```

**Usage:**
```bash
./process.sh -n Jetha -a 45
# Output: Name: Jetha, Age: 45
```

---

# **üìù Bash Conditionals: Short Notes**

## **‚úÖ BASIC IF-THEN-ELSE**

### **Syntax:**
```bash
if [ condition ]; then
    # commands
elif [ condition ]; then
    # commands  
else
    # commands
fi
```

### **Example 1: Number Check**
```bash
#!/bin/bash
read -p "Enter a number: " num

if [ $num -gt 10 ]; then
    echo "$num is greater than 10"
elif [ $num -eq 10 ]; then
    echo "$num equals 10"
else
    echo "$num is less than 10"
fi
```
**Output:**
```bash
Enter a number: 15
# Output: 15 is greater than 10

Enter a number: 5  
# Output: 5 is less than 10
```

---

## **üéØ TEST OPERATORS**

### **1. Numeric Comparisons**
| Operator | Meaning | Example |
|----------|---------|---------|
| `-eq` | Equal | `[ $a -eq $b ]` |
| `-ne` | Not equal | `[ $a -ne $b ]` |
| `-gt` | Greater than | `[ $a -gt $b ]` |
| `-lt` | Less than | `[ $a -lt $b ]` |
| `-ge` | Greater or equal | `[ $a -ge $b ]` |
| `-le` | Less or equal | `[ $a -le $b ]` |

### **Example 2: Age Check**
```bash
#!/bin/bash
age=25

if [ $age -ge 18 ]; then
    echo "You can vote!"
else
    echo "Too young to vote"
fi
```
**Output:** `You can vote!`

---

### **2. String Comparisons**
| Operator | Meaning | Example |
|----------|---------|---------|
| `=` or `==` | Equal | `[ "$a" = "$b" ]` |
| `!=` | Not equal | `[ "$a" != "$b" ]` |
| `-z` | Empty string | `[ -z "$a" ]` |
| `-n` | Not empty | `[ -n "$a" ]` |
| `<` | Less than (ASCII) | `[[ "$a" < "$b" ]]` |
| `>` | Greater than | `[[ "$a" > "$b" ]]` |

### **Example 3: Username Check**
```bash
#!/bin/bash
read -p "Enter username: " username

if [ -z "$username" ]; then
    echo "Username cannot be empty!"
elif [ "$username" = "admin" ]; then
    echo "Welcome Administrator"
else
    echo "Hello $username"
fi
```
**Output:**
```bash
Enter username: admin
# Output: Welcome Administrator

Enter username: 
# Output: Username cannot be empty!
```

---

### **3. File Tests**
| Operator | Checks | Example |
|----------|--------|---------|
| `-e` | File exists | `[ -e file.txt ]` |
| `-f` | Regular file | `[ -f file.txt ]` |
| `-d` | Directory | `[ -d /home ]` |
| `-s` | File not empty | `[ -s data.txt ]` |
| `-r` | Readable | `[ -r file.txt ]` |
| `-w` | Writable | `[ -w file.txt ]` |
| `-x` | Executable | `[ -x script.sh ]` |

### **Example 4: File Operations**
```bash
#!/bin/bash
file="hello.txt"

if [ -f "$file" ]; then
    echo "$file exists"
    if [ -w "$file" ]; then
        echo "You can write to $file"
    fi
else
    echo "$file not found"
fi
```
**Output:**
```bash
# If hello.txt exists and is writable:
# hello.txt exists
# You can write to hello.txt
```

---

## **üîß CONDITIONAL VARIATIONS**

### **1. Case Statement (Switch-Case)**
```bash
#!/bin/bash
read -p "Enter fruit: " fruit

case $fruit in
    apple)
        echo "Red fruit"
        ;;
    banana)
        echo "Yellow fruit"
        ;;
    orange|mango)
        echo "Tropical fruit"
        ;;
    *)
        echo "Unknown fruit"
        ;;
esac
```
**Output:**
```bash
Enter fruit: apple
# Output: Red fruit

Enter fruit: mango
# Output: Tropical fruit
```

### **2. Logical Operators**
| Operator | Meaning | Example |
|----------|---------|---------|
| `&&` | AND | `[ $a -gt 0 ] && [ $a -lt 10 ]` |
| `||` | OR | `[ $a -eq 0 ] || [ $b -eq 0 ]` |
| `!` | NOT | `[ ! -f "$file" ]` |

### **Example 5: Complex Condition**
```bash
#!/bin/bash
read -p "Enter age: " age
read -p "Have ID? (yes/no): " has_id

if [ $age -ge 18 ] && [ "$has_id" = "yes" ]; then
    echo "Entry allowed"
elif [ $age -ge 18 ] && [ "$has_id" = "no" ]; then
    echo "Need ID proof"
else
    echo "Entry denied"
fi
```
**Output:**
```bash
Enter age: 20
Have ID? (yes/no): yes
# Output: Entry allowed
```

---

### **3. Double Brackets `[[ ]]` (Extended)**
- More features than `[ ]`
- Supports `&&`, `||` inside
- Pattern matching with `=~`

### **Example 6: Pattern Matching**
```bash
#!/bin/bash
email="user@example.com"

if [[ "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
    echo "Valid email"
else
    echo "Invalid email"
fi
```
**Output:** `Valid email`

---

### **4. Arithmetic Conditions `(( ))`**
```bash
#!/bin/bash
a=10
b=20

if (( a < b )); then
    echo "$a is less than $b"
fi

if (( (a + b) > 25 )); then
    echo "Sum is greater than 25"
fi
```
**Output:**
```
10 is less than 20
Sum is greater than 25
```

---

## **‚ö†Ô∏è COMMON PITFALLS**

### **WRONG:**
```bash
if [ $var = "text" ]    # Missing quotes if var empty
if [ $num > 10 ]        # > is redirection, not comparison
if [ $a == $b ]         # Single = for string in [ ]
```

### **RIGHT:**
```bash
if [ "$var" = "text" ]  # Always quote variables
if [ $num -gt 10 ]      # Use -gt for numbers
if [[ $a == $b ]]       # == works in [[ ]]
```

---

## **üìä PRACTICAL EXAMPLES**

### **Example 7: System Check Script**
```bash
#!/bin/bash
# system_check.sh

if [ $(whoami) = "root" ]; then
    echo "Running as root"
else
    echo "Run with sudo"
fi

if [ -d "/etc" ]; then
    echo "/etc directory exists"
fi

if [ -x "$(command -v git)" ]; then
    echo "Git is installed"
else
    echo "Git not found"
fi
```
**Output:**
```
Running as root
/etc directory exists  
Git is installed
```

### **Example 8: Backup Script with Conditions**
```bash
#!/bin/bash
source="$1"
dest="$2"

if [ $# -ne 2 ]; then
    echo "Usage: $0 source dest"
    exit 1
fi

if [ ! -e "$source" ]; then
    echo "Error: $source not found"
    exit 1
fi

if [ -e "$dest" ]; then
    read -p "$dest exists. Overwrite? (y/n): " choice
    if [ "$choice" != "y" ]; then
        echo "Backup cancelled"
        exit 0
    fi
fi

cp -r "$source" "$dest"
echo "Backup completed"
```

---

## **üéØ QUICK REFERENCE**

| Task | Syntax | Example |
|------|--------|---------|
| **Basic if** | `if [ ]; then` | `if [ -f file ]; then` |
| **If-else** | `if [ ]; then else fi` | `if [ $x -eq 1 ]; then echo "yes"; else echo "no"; fi` |
| **Case** | `case $var in pattern) ;; esac` | `case $fruit in apple) ;; esac` |
| **AND** | `&&` or `-a` | `[ $a -gt 0 ] && [ $b -gt 0 ]` |
| **OR** | `||` or `-o` | `[ $a -eq 0 ] || [ $b -eq 0 ]` |
| **File exists** | `-e` | `if [ -e file.txt ]; then` |
| **String empty** | `-z` | `if [ -z "$name" ]; then` |

---

## **üîç TEST YOURSELF**

**Q1: What's the output?**
```bash
x=5
y=10
if [ $x -lt $y ] && [ $y -gt 8 ]; then
    echo "Pass"
else
    echo "Fail"
fi
```
**Output:** `Pass`

**Q2: Fix this buggy code:**
```bash
if [ $USER = root ]; then
    echo "You are root"
fi
```
**Fixed:**
```bash
if [ "$USER" = "root" ]; then
    echo "You are root"
fi
```

---

## **‚úÖ BEST PRACTICES**

1. **Quote variables**: `"$var"` prevents empty variable errors
2. **Use `[[ ]]`** for advanced features (regex, pattern matching)
3. **Use `(( ))`** for arithmetic operations
4. **Indent code** for readability
5. **Add comments** for complex conditions
6. **Test edge cases**: empty strings, special characters

---

## **üöÄ MINI PROJECT: Grade Calculator**

```bash
#!/bin/bash
read -p "Enter marks (0-100): " marks

if (( marks >= 90 && marks <= 100 )); then
    grade="A+"
elif (( marks >= 80 )); then
    grade="A"
elif (( marks >= 70 )); then
    grade="B"
elif (( marks >= 60 )); then
    grade="C"
elif (( marks >= 50 )); then
    grade="D"
elif (( marks >= 0 )); then
    grade="F"
else
    echo "Invalid marks"
    exit 1
fi

echo "Marks: $marks, Grade: $grade"

# Additional check
if [[ "$grade" == "F" ]]; then
    echo "You need to improve!"
fi
```

**Output:**
```bash
Enter marks (0-100): 85
# Output: Marks: 85, Grade: A
```

---

# **üìù Bash Loops: Short Notes**

## **‚úÖ FOR LOOPS**

### **1. Basic For Loop**
```bash
for variable in list; do
    # commands
done
```

### **Example 1: Iterate List**
```bash
#!/bin/bash
for fruit in apple banana cherry mango; do
    echo "I like $fruit"
done
```
**Output:**
```
I like apple
I like banana  
I like cherry
I like mango
```

### **2. Iterate Over Files**
```bash
#!/bin/bash
for file in *.txt; do
    echo "Processing: $file"
    wc -l "$file"
done
```
**Output:**
```
Processing: notes.txt
5 notes.txt
Processing: data.txt
10 data.txt
```

---

## **üéØ WHILE LOOPS**

### **Syntax:**
```bash
while [ condition ]; do
    # commands
done
```

### **Example 2: Countdown**
```bash
#!/bin/bash
count=5
while [ $count -gt 0 ]; do
    echo "Count: $count"
    sleep 1
    count=$((count - 1))
done
echo "Blast off!"
```
**Output:**
```
Count: 5
Count: 4
Count: 3  
Count: 2
Count: 1
Blast off!
```

### **Example 3: Read File Line by Line**
```bash
#!/bin/bash
while read line; do
    echo "Line: $line"
done < data.txt
```
**Output (if data.txt has 3 lines):**
```
Line: First line
Line: Second line  
Line: Third line
```

---

## **üîß UNTIL LOOPS**

### **Syntax:** (Runs UNTIL condition becomes true)
```bash
until [ condition ]; do
    # commands
done
```

### **Example 4: Wait for Service**
```bash
#!/bin/bash
counter=1
until [ $counter -gt 3 ]; do
    echo "Attempt $counter: Checking service..."
    # ping -c1 server &>/dev/null && break
    sleep 2
    counter=$((counter + 1))
done
echo "Done checking"
```
**Output:**
```
Attempt 1: Checking service...
Attempt 2: Checking service...
Attempt 3: Checking service...
Done checking
```

---

## **‚ö° LOOP VARIATIONS & TRICKS**

### **1. C-style For Loop**
```bash
#!/bin/bash
for ((i=1; i<=5; i++)); do
    echo "Iteration $i"
done
```
**Output:**
```
Iteration 1
Iteration 2
Iteration 3
Iteration 4
Iteration 5
```

### **2. Infinite Loop**
```bash
#!/bin/bash
while true; do
    echo "Press Ctrl+C to stop"
    sleep 2
done
```

### **3. Loop with Continue**
```bash
#!/bin/bash
for i in {1..10}; do
    if [ $((i % 2)) -eq 0 ]; then
        continue  # Skip even numbers
    fi
    echo "Odd: $i"
done
```
**Output:**
```
Odd: 1
Odd: 3
Odd: 5
Odd: 7
Odd: 9
```

### **4. Loop with Break**
```bash
#!/bin/bash
for i in {1..10}; do
    echo "Number: $i"
    if [ $i -eq 5 ]; then
        echo "Stopping at 5"
        break
    fi
done
```
**Output:**
```
Number: 1
Number: 2
Number: 3
Number: 4
Number: 5
Stopping at 5
```

---

## **üí° PRACTICAL EXAMPLES**

### **Example 5: Backup Multiple Files**
```bash
#!/bin/bash
# backup_files.sh
files=("/etc/passwd" "/etc/hosts" "/var/log/syslog")

for file in "${files[@]}"; do
    if [ -f "$file" ]; then
        cp "$file" "/backup/$(basename "$file").bak"
        echo "Backed up: $file"
    else
        echo "Warning: $file not found"
    fi
done
```

### **Example 6: User Management**
```bash
#!/bin/bash
# add_users.sh
usernames=("jetha" "babitaji" "iyer" "hathi")

for user in "${usernames[@]}"; do
    if id "$user" &>/dev/null; then
        echo "User $user already exists"
    else
        sudo useradd -m "$user"
        echo "Created user: $user"
    fi
done
```

### **Example 7: Process Monitor**
```bash
#!/bin/bash
# monitor.sh
process="nginx"
attempts=0

until pgrep -x "$process" >/dev/null; do
    echo "$process not running. Attempt $((attempts+1))"
    attempts=$((attempts + 1))
    
    if [ $attempts -eq 3 ]; then
        echo "Starting $process..."
        sudo systemctl start "$process"
    elif [ $attempts -ge 5 ]; then
        echo "Failed to start $process"
        exit 1
    fi
    sleep 3
done

echo "$process is running!"
```

---

## **‚ö†Ô∏è COMMON PITFALLS**

### **WRONG:**
```bash
for file in $(ls *.txt)     # Breaks with spaces in filenames
while read line              # Issues with leading/trailing spaces
for i in {1..$max}          # Brace expansion before variable
```

### **RIGHT:**
```bash
for file in *.txt           # Use glob directly
while IFS= read -r line     # Preserve spaces
for ((i=1; i<=max; i++))    # C-style for variables
```

---

## **üìä LOOP CONTROL STATEMENTS**

| Statement | Effect | Example |
|-----------|--------|---------|
| `break` | Exit loop | `break` or `break 2` (exit 2 levels) |
| `continue` | Skip to next iteration | `continue` |
| `exit` | Exit entire script | `exit 1` (with error code) |

### **Example 8: Nested Loops with Break**
```bash
#!/bin/bash
for i in {1..3}; do
    echo "Outer loop: $i"
    for j in {1..3}; do
        echo "  Inner loop: $j"
        if [ $j -eq 2 ]; then
            break 2  # Break out of 2 levels
        fi
    done
done
```
**Output:**
```
Outer loop: 1
  Inner loop: 1
  Inner loop: 2
# Loop stops here due to break 2
```

---

## **üéØ SPECIAL LOOP SYNTAX**

### **1. Brace Expansion**
```bash
for i in {1..5}; do echo $i; done
for i in {01..10}; do echo $i; done  # Zero-padded
for i in {A..E}; do echo $i; done    # Letters
```

### **2. Sequence Command**
```bash
for i in $(seq 1 2 10); do           # 1 to 10 step 2
    echo $i
done
# Output: 1 3 5 7 9
```

### **3. Command Output**
```bash
for user in $(cut -d: -f1 /etc/passwd | head -5); do
    echo "User: $user"
done
```

### **4. Array Iteration**
```bash
colors=("red" "green" "blue")
for color in "${colors[@]}"; do
    echo "Color: $color"
done
```

---

## **üîç REAL-WORLD USE CASES**

### **Case 1: Log Rotation**
```bash
#!/bin/bash
# rotate_logs.sh
log_dir="/var/log/myapp"
days_to_keep=7

for logfile in "$log_dir"/*.log; do
    if [ -f "$logfile" ]; then
        if find "$logfile" -mtime +$days_to_keep | grep -q .; then
            echo "Archiving: $logfile"
            gzip "$logfile"
        fi
    fi
done
```

### **Case 2: Bulk Image Processing**
```bash
#!/bin/bash
# convert_images.sh
counter=1
for image in *.jpg *.png; do
    if [ -f "$image" ]; then
        new_name="image_$(printf "%03d" $counter).jpg"
        convert "$image" -resize 800x600 "$new_name"
        echo "Converted: $image -> $new_name"
        counter=$((counter + 1))
    fi
done
```

### **Case 3: Ping Multiple Hosts**
```bash
#!/bin/bash
# network_check.sh
hosts=("google.com" "github.com" "example.com")

for host in "${hosts[@]}"; do
    if ping -c 1 "$host" &>/dev/null; then
        echo "‚úÖ $host is reachable"
    else
        echo "‚ùå $host is down"
    fi
done
```

---

## **‚úÖ BEST PRACTICES**

1. **Quote variables** in loops: `"$var"`
2. **Use `-r` with `read`** to preserve backslashes
3. **Set `IFS`** for specific delimiter needs
4. **Avoid `for i in $(ls)`** - use glob patterns instead
5. **Add error handling** inside loops
6. **Use meaningful variable names** (not just i, j)

---

## **üöÄ MINI PROJECT: Password Generator**

```bash
#!/bin/bash
# generate_passwords.sh
read -p "How many passwords? " count
read -p "Password length? " length

echo "Generating $count passwords of length $length..."
echo "=============================="

for ((i=1; i<=count; i++)); do
    password=$(tr -dc 'A-Za-z0-9!@#$%' < /dev/urandom | head -c $length)
    echo "$i: $password"
    
    # Strength check
    if [[ ${#password} -ge 12 ]] && [[ "$password" =~ [A-Z] ]] && \
       [[ "$password" =~ [0-9] ]] && [[ "$password" =~ [!@#$%] ]]; then
        echo "   [STRONG]"
    else
        echo "   [WEAK]"
    fi
done
```

**Output:**
```
How many passwords? 3
Password length? 10
Generating 3 passwords of length 10...
==============================
1: aB3$fG7!kL
   [STRONG]
2: abcdefghij
   [WEAK]
3: 123!@#qWeR
   [STRONG]
```

---

## **üìã QUICK REFERENCE**

| Loop Type | When to Use | Example |
|-----------|-------------|---------|
| `for` | Known iterations | `for file in *.txt` |
| `while` | Condition-based | `while [ $x -lt 10 ]` |
| `until` | Run until true | `until service is up` |
| `C-style` | Numeric ranges | `for ((i=0; i<10; i++))` |

---

## **üîç TEST YOURSELF**

**Q1: What's the output?**
```bash
for i in {1..3}; do
    for j in {1..2}; do
        echo "$i-$j"
    done
done
```
**Output:**
```
1-1
1-2
2-1
2-2
3-1
3-2
```

**Q2: Fix this infinite loop:**
```bash
x=1
while [ $x -lt 5 ]; do
    echo "Number: $x"
done
```
**Fixed:**
```bash
x=1
while [ $x -lt 5 ]; do
    echo "Number: $x"
    x=$((x + 1))
done
```

---

**Loops are your automation superpower! Master them to handle repetitive tasks efficiently.** üîÑ
